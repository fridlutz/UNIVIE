/*
 * generated by Xtext
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.xtext.example.mydsl.myDsl.Document
import org.eclipse.emf.ecore.EObject
import org.xtext.example.mydsl.myDsl.UnformattedText
import org.xtext.example.mydsl.myDsl.FormattedText
import org.xtext.example.mydsl.myDsl.ItalicText
import org.xtext.example.mydsl.myDsl.BoldText
import org.xtext.example.mydsl.myDsl.ItalicBoldText
import org.xtext.example.mydsl.myDsl.InternalLink
import org.xtext.example.mydsl.myDsl.ExternalLink
import org.xtext.example.mydsl.myDsl.FormattedTextWithoutLinks
import org.xtext.example.mydsl.myDsl.Heading
import org.xtext.example.mydsl.myDsl.Heading2
import org.xtext.example.mydsl.myDsl.Heading3
import org.xtext.example.mydsl.myDsl.Heading4
import org.xtext.example.mydsl.myDsl.File
import org.eclipse.emf.common.util.EList
import java.util.Iterator
import org.xtext.example.mydsl.myDsl.BlockQuote
import org.xtext.example.mydsl.myDsl.TextElement
import org.xtext.example.mydsl.myDsl.List
import org.xtext.example.mydsl.myDsl.AbstractElement
import org.xtext.example.mydsl.myDsl.Template
import org.xtext.example.mydsl.myDsl.Comment
import org.xtext.example.mydsl.myDsl.OrderedList
import org.xtext.example.mydsl.myDsl.UnorderedList
import org.xtext.example.mydsl.myDsl.OrderedListItem
import org.xtext.example.mydsl.myDsl.UnorderedListItem
import org.xtext.example.mydsl.myDsl.Metadata
import org.xtext.example.mydsl.myDsl.MainInformation
import org.xtext.example.mydsl.myDsl.ActualInformation
import org.xtext.example.mydsl.myDsl.Category

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator implements IGenerator {
	
	var static int counter = 1;
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		fsa.generateFile("wiki.html", toHtml(resource))
	}
	
	def static Document getDocument(Resource resource){
		return resource.allContents.head as Document
	}
	
	/**
	 * Method to convert the model into an HTML representation.
	 */
	def static toHtml(Resource resource) '''
	«val document = getDocument(resource)»
	<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
	<html>
		<head>
			<title>Wikipedia Document</title>
		</head>
		<body>
		<h1>«analyzeFormattedText(document.title.heading)»</h1>
		<hr>
		«analyzeAbstractElementList(document.elements)»
		«analyzeCategories(document.categories)»
		</body>
	</html>
	'''

	/**
	 * Method to analyze a list of AbstractElements.
	 * 
	 * @return the final string containing the representation of all AbstractElements in the document.
	 */
	def static String analyzeAbstractElementList(EList<AbstractElement> list) {
		var String string = "";
		var Iterator<AbstractElement> iter = list.iterator;

		while (iter.hasNext()) {
			string += analyzeAbstractElement(iter.next());
		}
		
		return string;
	}
	
	/**
	 * Method to analyze an AbstractElement.
	 * 
	 * @return the formatted string.
	 */
	def static String analyzeAbstractElement(AbstractElement element) {
		var EObject obj = element.element;
		var String string = "";
		
		switch(obj) {
			case obj instanceof Template:
				string = analyzeTemplate(obj as Template)
			case obj instanceof Heading:
				string = getHeading(obj as Heading)
			case obj instanceof TextElement:
				string = analyzeTextElement(obj as TextElement)
			case obj instanceof Comment:
				string = ""	// ignore comments in the actual representation
			default: string += "PARSING ERROR: AbstractElement could not be parsed."
		}
		
		return string;
	}
	
	/**
	 * Method to analyze a TextElement.
	 * 
	 * @return the formatted string.
	 */
	def static String analyzeTextElement(TextElement element) {
		var EObject obj = element.element;
		var String string = "";
		
		switch(obj) {
			case obj instanceof BlockQuote:
				string = getBlockQuote(obj as BlockQuote)
			case obj instanceof File:
				string = getFile(obj as File)
			case obj instanceof List:
				string = getList(obj as List)
			case obj instanceof FormattedText:
				string = analyzeFormattedText(obj as FormattedText)
			default: string += "PARSING ERROR: TextElement could not be parsed."
		}
		
		return string;
	}
	
	/**
	 * Method to analyze a FormattedText.
	 * 
	 * @return the formatted string.
	 */
	def static String analyzeFormattedText(FormattedText text) {
		var EObject obj = text.formattedText;
		var String string = "";
		
		switch(obj) {
			case obj instanceof ItalicText:
				string = getItalicTextValue(obj as ItalicText)
			case obj instanceof BoldText:
				string = getBoldTextValue(obj as BoldText)
			case obj instanceof ItalicBoldText:
				string = getItalicBoldTextValue(obj as ItalicBoldText)
			case obj instanceof InternalLink:
				string = getInternalLink(obj as InternalLink)
			case obj instanceof ExternalLink:
				string = getExternalLink(obj as ExternalLink)
			case obj instanceof UnformattedText:
				string = getUnformattedTextValue(obj as UnformattedText)
			default: string += "PARSING ERROR: FormattedText could not be parsed."
		}
		
		return string;
	}
	
	/**
	 * Method to analyze a FormattedTextWithoutLinks.
	 * 
	 * @return the formatted string.
	 */
	def static String analyzeFormattedTextWithoutLinks(FormattedTextWithoutLinks text) {
		var EObject obj = text.formattedTextWithoutLinks;
		var String string = "";
		
		switch(obj) {
			case obj instanceof ItalicText:
				string = getItalicTextValue(obj as ItalicText)
			case obj instanceof BoldText:
				string = getBoldTextValue(obj as BoldText)
			case obj instanceof ItalicBoldText:
				string = getItalicBoldTextValue(obj as ItalicBoldText)
			case obj instanceof UnformattedText:
				string = getUnformattedTextValue(obj as UnformattedText)
			default: string += "PARSING ERROR: FormattedTextWithoutLinks could not be parsed."
		}
		
		return string;
	}
	
	/**
	 * Method to get the value of an UnformattedText.
	 * 
	 * @return the plain string value.
	 */
	def static String getUnformattedTextValue(UnformattedText unformattedText) {
		return unformattedText.text;
	}
	
	/**
	 * Method to get the value of an ItalicText.
	 * 
	 * @return the formatted italic string.
	 */
	def static String getItalicTextValue(ItalicText italicText) {
		var EObject obj = italicText.italicText;
		var String string = "";
		
		switch(obj) {
			case obj instanceof InternalLink:
				string = getInternalLink(obj as InternalLink)
			case obj instanceof ExternalLink:
				string = getExternalLink(obj as ExternalLink)
			case obj instanceof UnformattedText:
				string = getUnformattedTextValue(obj as UnformattedText)
			default: string += "PARSING ERROR: ItalicText could not be parsed."
		}
		
		return "<i>" + string + "</i>";
	}
	
	/**
	 * Method to get the value of a BoldText.
	 * 
	 * @return the formatted bold string.
	 */
	def static String getBoldTextValue(BoldText boldText) {
		var EObject obj = boldText.boldText;
		var String string = "";
		
		switch(obj) {
			case obj instanceof InternalLink:
				string = getInternalLink(obj as InternalLink)
			case obj instanceof ExternalLink:
				string = getExternalLink(obj as ExternalLink)
			case obj instanceof UnformattedText:
				string = getUnformattedTextValue(obj as UnformattedText)
			default: string += "PARSING ERROR: BoldText could not be parsed."
		}
		
		return "<b>" + string + "</b>";
	}
	
	/**
	 * Method to get the value of a ItalicBoldText.
	 * 
	 * @return the formatted italic bold string.
	 */
	def static String getItalicBoldTextValue(ItalicBoldText italicBoldText) {
		var EObject obj = italicBoldText.italicBoldText;
		var String string = "";
		
		switch(obj) {
			case obj instanceof InternalLink:
				string = getInternalLink(obj as InternalLink)
			case obj instanceof ExternalLink:
				string = getExternalLink(obj as ExternalLink)
			case obj instanceof UnformattedText:
				string = getUnformattedTextValue(obj as UnformattedText)
			default: string += "PARSING ERROR: ItalicBoldText could not be parsed."
		}
		
		return "<i><b>" + string + "</b></i>";
	}
	
	/**
	 * Method to get the representation of an InternalLink.
	 * 
	 * @return the internal link string.
	 */
	def static String getInternalLink(InternalLink internalLink) {
		var String string = "";
		
		var String linkName = getUnformattedTextValue(internalLink.linkName);
		var String renamedLink = null;
		
		// check optional parameter
		if (internalLink.renamedLink != null)
			renamedLink = analyzeFormattedTextWithoutLinks(internalLink.renamedLink);
		
		string = '<a href="https://en.wikipedia.org/wiki/' + linkName + '">';
		
		if (renamedLink == null) {
			string += linkName
		} else {
			string += renamedLink
		}
		
		string += '</a>'
		
		return string;
	}
	
	/**
	 * Method to get the representation of an ExternalLink.
	 * 
	 * @return the external link string.
	 */
	 // TODO: By now the XTEXT implementation cannot parse the renaming part of external links because whitespaces are allowed for links.
	def static String getExternalLink(ExternalLink externalLink) {
		var String string = "";
		
		var String linkName = getUnformattedTextValue(externalLink.linkName);
		var String renamedLink = null;
		
		// check optional parameter
		if (externalLink.renamedLink != null)
			renamedLink = analyzeFormattedTextWithoutLinks(externalLink.renamedLink);
		
		string = '<a href="' + linkName + '">';
		
		if (renamedLink == null) {
			string += "[" + (counter++) + "]";
		} else {
			string += renamedLink;
		}
		
		string += '<img src="hyperlink.jpg"></a>';
		
		return string;
	}
	
	/**
	 * Method to get the representation of a File.
	 * 
	 * @return the file string.
	 */
	def static String getFile(File file) {
		var String string = "";
		
		var String fileName = getUnformattedTextValue(file.fileName);
		var String viewType = null;
		var String description = null;
		var EList<FormattedTextWithoutLinks> additionalDescriptionItems = null;
		var Iterator<FormattedTextWithoutLinks> iter = null;
		
		// check optional parameter
		if (file.viewType != null) {
			viewType = file.viewType;
			viewType.replaceAll("|", "");
		}
		
		if (file.text != null) {
			description = analyzeFormattedTextWithoutLinks(file.text);
		}
			
		if (file.additional != null) {
			additionalDescriptionItems = file.additional;
			iter = additionalDescriptionItems.iterator;
			while (iter.hasNext()) {
				description += analyzeFormattedTextWithoutLinks(iter.next());
			}
		}
		
		string = "\n";
		string += '<div>\n';
		string += '<div>\n';
		string += '<img src="' + fileName + '">\n';
		string += "</div>\n";
		string += "<div>\n";
		string += description;
		string += "\n</div>\n";
		string += "</div>";
		string += "\n";
		
		return string;
	}
	
	/**
	 * Method to get the representation of a Heading.
	 * Note: Heading1 is not supported because it can only appear at the beginning of the document.
	 * 
	 * @return the heading as string.
	 */
	def static String getHeading(Heading heading) {
		var String string = "";
		var EObject obj = heading.heading;
		
		string += "\n";
		
		switch(obj) {
			case obj instanceof Heading2:
				string += "<h2>" + analyzeFormattedText((obj as Heading2).heading) + "</h2>\n<hr>"
			case obj instanceof Heading3:
				string += "<h3>" + analyzeFormattedText((obj as Heading3).heading) + "</h3>"
			case obj instanceof Heading4:
				string += "<h4>" + analyzeFormattedText((obj as Heading4).heading) + "</h4>"
			default: string += "PARSING ERROR: Heading could not be parsed."
		}
		
		string += "\n"
		
		return string;
	}
	
	/**
	 * Method to get the representation of a BlockQuote.
	 * 
	 * @return the block quote as string.
	 */
	def static String getBlockQuote(BlockQuote blockQuote) {
		var String string = "";
		var FormattedText text = blockQuote.blockQuoteText;
		var EList<FormattedText> additionalText = null;
		var Iterator<FormattedText> iter = null;

		string += "\n";
		string += "<blockquote>"
		
		string += analyzeFormattedText(text);

		// check optional parameter
		if (blockQuote.additional != null) {
			additionalText = blockQuote.additional;
			iter = additionalText.iterator;
			while (iter.hasNext()) {
				string += analyzeFormattedText(iter.next());
			}
		}
		
		string += "</blockquote>"
		string += "\n";
		
		return string;
	}
	
	/**
	 * Method to get the representation of a List.
	 * 
	 * @return the list as string.
	 */
	def static String getList(List list) {
		var String string = "";
		var EObject obj = list.list;

		switch(obj) {
			case obj instanceof OrderedList:
				string += getOrderedList((obj as OrderedList))
			case obj instanceof UnorderedList:
				string += getUnorderedList((obj as UnorderedList))
			default: string += "PARSING ERROR: List could not be parsed."
		}
		
		return string;
	}
	
	/**
	 * Method to get the representation of an OrderedList.
	 * 
	 * @return the ordered list as string.
	 */
	def static String getOrderedList(OrderedList list) {
		var String string = "";
		var EList<OrderedListItem> items = list.items;
		var Iterator<OrderedListItem> iter = items.iterator;

		string += "\n";
		string += "<ol>"

		while (iter.hasNext()) {
			string += getOrderedListItem(iter.next());
		}

		string += "</ol>";
		string += "\n";
		
		return string;
	}
	
	/**
	 * Method to get the representation of an OrderedListItem.
	 * 
	 * @return the ordered list item as string.
	 */
	def static String getOrderedListItem(OrderedListItem item) {
		var String string = "";

		string += "\n";
		string += "<li>"

		var EObject obj = item.item;

		switch(obj) {
			case obj instanceof FormattedText:
				string += analyzeFormattedText(obj as FormattedText)
			case obj instanceof List:
				string += getList(obj as List)
			default: string += "PARSING ERROR: OrderedListItem could not be parsed."
		}

		string += "</li>";
		string += "\n";
		
		return string;
	}
	
	/**
	 * Method to get the representation of an UnorderedList.
	 * 
	 * @return the unordered list as string.
	 */
	def static String getUnorderedList(UnorderedList list) {
		var String string = "";
		var EList<UnorderedListItem> items = list.items;
		var Iterator<UnorderedListItem> iter = items.iterator;

		string += "\n";
		string += "<ul>"

		while (iter.hasNext()) {
			string += getUnorderedListItem(iter.next());
		}

		string += "</ul>";
		string += "\n";
		
		return string;
	}
	
	/**
	 * Method to get the representation of an UnorderedListItem.
	 * 
	 * @return the unordered list item as string.
	 */
	def static String getUnorderedListItem(UnorderedListItem item) {
		var String string = "";

		string += "\n";
		string += "<li>"

		var EObject obj = item.item;

		switch(obj) {
			case obj instanceof FormattedText:
				string += analyzeFormattedText(obj as FormattedText)
			case obj instanceof List:
				string += getList(obj as List)
			default: string += "PARSING ERROR: UnorderedListItem could not be parsed."
		}

		string += "</li>";
		string += "\n";
		
		return string;
	}
	
	/**
	 * Method to analyze a Template.
	 * 
	 * @return the formatted string.
	 */
	def static String analyzeTemplate(Template template) {
		var String string = "";
		
		var EObject obj = template.template.type;
		
		string += "\n<p><i>";
		
		switch(obj) {
			case obj instanceof Metadata:
				string += getMetadata(obj as Metadata)
			case obj instanceof MainInformation:
				string += getMainInformation(obj as MainInformation)
			default: string += "PARSING ERROR: Template could not be parsed."
		}	
		
		string += "</i></p>\n"
		
		return string;
	}
	
	/**
	 * Method to get a Metadata.
	 * 
	 * @return the formatted string.
	 */
	def static String getMetadata(Metadata meta) {
		var String string = "";
		
		string += "This page is about ";
		string += getUnformattedTextValue(meta.about.aboutText);
		string += ". ";
		
		var ActualInformation actualInfo = meta.actualInfo;
		
		if (actualInfo != null) {
			string += getActualInformation(actualInfo);
		}
		
		return string;
	}
	
	/**
	 * Method to get the ActualInformation.
	 * 
	 * @return the formatted string.
	 */
	def static String getActualInformation(ActualInformation info) {
		var String string = "";
		
		string += "For ";
		string += getUnformattedTextValue(info.informationOnWhat);
		string += ", see ";
		
		var String temp = getUnformattedTextValue(info.link);
		string += '<a href="https://en.wikipedia.org/wiki/' + temp + '">';
		string += temp;
		string += '</a>';
		
		var EList<UnformattedText> list = info.additionalLinks;
		var Iterator<UnformattedText> iter = null;
		
		if (list != null) {
			iter = list.iterator;
			while (iter.hasNext()) {
				temp = getUnformattedTextValue(iter.next());
				if (iter.hasNext()) {
					string += ", ";
				} else {
					string += " and ";				
				}
				string += '<a href="https://en.wikipedia.org/wiki/' + temp + '">';
				string += temp;
				string += '</a>';
			}
		}
		
		string += ".";
		
		return string;
	}
	
	/**
	 * Method to get a MainInformation.
	 * 
	 * @return the formatted string.
	 */
	def static String getMainInformation(MainInformation main) {
		var String string = "";
		
		var String link = getUnformattedTextValue(main.link);
		
		string += "Main article: ";
		string += '<a href="https://en.wikipedia.org/wiki/' + link + '">';
		string += link;
		string += '</a>';
		
		return string;
	}
	
	/**
	 * Method to get a Category.
	 * 
	 * @return the formatted string.
	 */
	def static String analyzeCategories(EList<Category> categories) {
		var String string = "";
		
		var Iterator<Category> iter = null;
		
		if (categories != null) {
			iter = categories.iterator;
			
			string += '\n<div>';
			
			string += '<a href="https://en.wikipedia.org/wiki/Help:Category">Categories:</a> ';	
			
			while (iter.hasNext()) {
				var String link = getUnformattedTextValue(iter.next().categoryLink);
				string += '<a href="https://en.wikipedia.org/wiki/' + link + '">';
				string += link;
				string += '</a>';		
				if (iter.hasNext()) {
					string += " | "
				}		
			}
			
			string += "</div>\n"
		}
		

		
		return string;
	}
}
