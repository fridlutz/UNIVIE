/*
 * generated by Xtext
 */
package at.ac.univie.swa.ase2015.a9902268.task3.serializer;

import at.ac.univie.swa.ase2015.a9902268.task3.services.WikiMLGrammarAccess;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.AboutTemplate;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.AnyTextSequence;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.BlockQuote;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.Bold;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.Category;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.External;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.Heading2;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.Heading3;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.Heading4;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.Heading5;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.Image;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.Internal;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.Italic;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.ItalicBold;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.MainTemplate;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.OrderListItem;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.OrderedList;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.Paragraph;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.QuoteTemplate;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.Text;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.UnorderListItem;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.UnorderedList;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.WikiMLPackage;
import at.ac.univie.swa.ase2015.a9902268.task3.wikiML.WikiPage;
import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class WikiMLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private WikiMLGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == WikiMLPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case WikiMLPackage.ABOUT_TEMPLATE:
				sequence_AboutTemplate(context, (AboutTemplate) semanticObject); 
				return; 
			case WikiMLPackage.ANY_TEXT_SEQUENCE:
				sequence_AnyTextSequence(context, (AnyTextSequence) semanticObject); 
				return; 
			case WikiMLPackage.BLOCK_QUOTE:
				sequence_BlockQuote(context, (BlockQuote) semanticObject); 
				return; 
			case WikiMLPackage.BOLD:
				sequence_Bold(context, (Bold) semanticObject); 
				return; 
			case WikiMLPackage.CATEGORY:
				sequence_Category(context, (Category) semanticObject); 
				return; 
			case WikiMLPackage.EXTERNAL:
				sequence_External(context, (External) semanticObject); 
				return; 
			case WikiMLPackage.HEADING2:
				sequence_Heading2(context, (Heading2) semanticObject); 
				return; 
			case WikiMLPackage.HEADING3:
				sequence_Heading3(context, (Heading3) semanticObject); 
				return; 
			case WikiMLPackage.HEADING4:
				sequence_Heading4(context, (Heading4) semanticObject); 
				return; 
			case WikiMLPackage.HEADING5:
				sequence_Heading5(context, (Heading5) semanticObject); 
				return; 
			case WikiMLPackage.IMAGE:
				sequence_Image(context, (Image) semanticObject); 
				return; 
			case WikiMLPackage.INTERNAL:
				sequence_Internal(context, (Internal) semanticObject); 
				return; 
			case WikiMLPackage.ITALIC:
				sequence_Italic(context, (Italic) semanticObject); 
				return; 
			case WikiMLPackage.ITALIC_BOLD:
				sequence_ItalicBold(context, (ItalicBold) semanticObject); 
				return; 
			case WikiMLPackage.MAIN_TEMPLATE:
				sequence_MainTemplate(context, (MainTemplate) semanticObject); 
				return; 
			case WikiMLPackage.ORDER_LIST_ITEM:
				sequence_OrderListItem(context, (OrderListItem) semanticObject); 
				return; 
			case WikiMLPackage.ORDERED_LIST:
				sequence_OrderedList(context, (OrderedList) semanticObject); 
				return; 
			case WikiMLPackage.PARAGRAPH:
				sequence_Paragraph(context, (Paragraph) semanticObject); 
				return; 
			case WikiMLPackage.QUOTE_TEMPLATE:
				sequence_QuoteTemplate(context, (QuoteTemplate) semanticObject); 
				return; 
			case WikiMLPackage.TEXT:
				sequence_Text(context, (Text) semanticObject); 
				return; 
			case WikiMLPackage.UNORDER_LIST_ITEM:
				sequence_UnorderListItem(context, (UnorderListItem) semanticObject); 
				return; 
			case WikiMLPackage.UNORDERED_LIST:
				sequence_UnorderedList(context, (UnorderedList) semanticObject); 
				return; 
			case WikiMLPackage.WIKI_PAGE:
				sequence_WikiPage(context, (WikiPage) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (type='about' content+=AnyTextSequence+)
	 */
	protected void sequence_AboutTemplate(EObject context, AboutTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (content+=AnyText*)
	 */
	protected void sequence_AnyTextSequence(EObject context, AnyTextSequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     content=AnyTextSequence
	 */
	protected void sequence_BlockQuote(EObject context, BlockQuote semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, WikiMLPackage.Literals.BLOCK_QUOTE__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WikiMLPackage.Literals.BLOCK_QUOTE__CONTENT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBlockQuoteAccess().getContentAnyTextSequenceParserRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=AbstractUnformattedInlineContent
	 */
	protected void sequence_Bold(EObject context, Bold semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, WikiMLPackage.Literals.ABSTRACT_FORMATTED_INLINE_CONTENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WikiMLPackage.Literals.ABSTRACT_FORMATTED_INLINE_CONTENT__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBoldAccess().getNameAbstractUnformattedInlineContentParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=Text value='|*?'?)
	 */
	protected void sequence_Category(EObject context, Category semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=URL (altText=AbstractUnformattedInlineContent | altText=AbstractFormattedInlineContent)?)
	 */
	protected void sequence_External(EObject context, External semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     headingValue2=AbstractUnformattedInlineContent
	 */
	protected void sequence_Heading2(EObject context, Heading2 semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, WikiMLPackage.Literals.HEADING2__HEADING_VALUE2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WikiMLPackage.Literals.HEADING2__HEADING_VALUE2));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getHeading2Access().getHeadingValue2AbstractUnformattedInlineContentParserRuleCall_1_0(), semanticObject.getHeadingValue2());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     headingValue3=AbstractUnformattedInlineContent
	 */
	protected void sequence_Heading3(EObject context, Heading3 semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, WikiMLPackage.Literals.HEADING3__HEADING_VALUE3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WikiMLPackage.Literals.HEADING3__HEADING_VALUE3));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getHeading3Access().getHeadingValue3AbstractUnformattedInlineContentParserRuleCall_1_0(), semanticObject.getHeadingValue3());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     headingValue4=AbstractUnformattedInlineContent
	 */
	protected void sequence_Heading4(EObject context, Heading4 semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, WikiMLPackage.Literals.HEADING4__HEADING_VALUE4) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WikiMLPackage.Literals.HEADING4__HEADING_VALUE4));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getHeading4Access().getHeadingValue4AbstractUnformattedInlineContentParserRuleCall_1_0(), semanticObject.getHeadingValue4());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     headingValue5=AbstractUnformattedInlineContent
	 */
	protected void sequence_Heading5(EObject context, Heading5 semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, WikiMLPackage.Literals.HEADING5__HEADING_VALUE5) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WikiMLPackage.Literals.HEADING5__HEADING_VALUE5));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getHeading5Access().getHeadingValue5AbstractUnformattedInlineContentParserRuleCall_1_0(), semanticObject.getHeadingValue5());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=URL type=ViewType hAlign=HorizontalAlign? altText=AbstractUnformattedInlineContent? caption=AnyTextSequence)
	 */
	protected void sequence_Image(EObject context, Image semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (link=[WikiPage|Name]? anchor=Text? (altText=AbstractUnformattedInlineContent | altText=AbstractFormattedInlineContent)?)
	 */
	protected void sequence_Internal(EObject context, Internal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=AbstractUnformattedInlineContent
	 */
	protected void sequence_ItalicBold(EObject context, ItalicBold semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, WikiMLPackage.Literals.ABSTRACT_FORMATTED_INLINE_CONTENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WikiMLPackage.Literals.ABSTRACT_FORMATTED_INLINE_CONTENT__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getItalicBoldAccess().getNameAbstractUnformattedInlineContentParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=AbstractUnformattedInlineContent
	 */
	protected void sequence_Italic(EObject context, Italic semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, WikiMLPackage.Literals.ABSTRACT_FORMATTED_INLINE_CONTENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WikiMLPackage.Literals.ABSTRACT_FORMATTED_INLINE_CONTENT__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getItalicAccess().getNameAbstractUnformattedInlineContentParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type='main' content+=AnyTextSequence+)
	 */
	protected void sequence_MainTemplate(EObject context, MainTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     itemtext=AnyTextSequence
	 */
	protected void sequence_OrderListItem(EObject context, OrderListItem semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, WikiMLPackage.Literals.ORDER_LIST_ITEM__ITEMTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WikiMLPackage.Literals.ORDER_LIST_ITEM__ITEMTEXT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOrderListItemAccess().getItemtextAnyTextSequenceParserRuleCall_1_0(), semanticObject.getItemtext());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (items+=OrderListItem+ end=Paragraph)
	 */
	protected void sequence_OrderedList(EObject context, OrderedList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     paragraph='
	 *     
	 *     '
	 */
	protected void sequence_Paragraph(EObject context, Paragraph semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, WikiMLPackage.Literals.PARAGRAPH__PARAGRAPH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WikiMLPackage.Literals.PARAGRAPH__PARAGRAPH));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParagraphAccess().getParagraphControl000dControl000aControl000dControl000aKeyword_0(), semanticObject.getParagraph());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     type='''
	 */
	protected void sequence_QuoteTemplate(EObject context, QuoteTemplate semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, WikiMLPackage.Literals.TEMPLATE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WikiMLPackage.Literals.TEMPLATE__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getQuoteTemplateAccess().getTypeApostropheKeyword_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=Name
	 */
	protected void sequence_Text(EObject context, Text semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, WikiMLPackage.Literals.TEXT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WikiMLPackage.Literals.TEXT__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTextAccess().getNameNameParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((level='*' | level='**') itemtext=AnyTextSequence)
	 */
	protected void sequence_UnorderListItem(EObject context, UnorderListItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (items+=UnorderListItem+ end=Paragraph)
	 */
	protected void sequence_UnorderedList(EObject context, UnorderedList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=Name elements+=ParagraphTypes*)
	 */
	protected void sequence_WikiPage(EObject context, WikiPage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
